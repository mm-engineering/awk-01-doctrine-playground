# As We Know, Episode 01

## I Want To Speak To The EntityManager

_Doctrine EntityManager Tips And Tricks_

This basic Symfony project is the playground for exploring various ways of interacting with [Doctrine](https://symfony.com/doc/current/doctrine.html) and its [`EntityManager`](https://www.doctrine-project.org/projects/doctrine-orm/en/2.8/tutorials/getting-started.html#obtaining-the-entitymanager).

## Prerequisites

1. Docker (e.g., Docker Desktop), accessible from a shell (e.g., `bash`).

We will run everything in containers, so there is no need to install anything else.

## Workshop Steps

### Install Playground

1. Clone this repository, e.g.:
   ```shell
   git clone https://github.com/mm-engineering/awk-01-doctrine-playground.git workshop
   ```
2. Go into the cloned directory, e.g.:
   ```shell
   cd workshop
   ```
3. Pull all dependencies, e.g.:
   ```shell
   docker run --rm --interactive --tty --volume $PWD:/app composer install
   ```
4. Assemble the containers from scratch:
   ```shell
   docker-compose build --no-cache --pull
   ```
5. Launch the containers in the background, e.g.:
   ```shell
   docker-compose up -d
   ```

### Exercise 1: Create Doctrine entity classes

Let’s create a handy shell alias for the following sections:

```shell
# Execute bin/console in docker-compose service named 'php' in current directory
alias dconsole='docker-compose exec php bin/console'
```

1. Create a couple of entities:
   1. Run `dconsole make:entity`. Name it `Warehouse`. No fields for now.
      1. Add field `name`. Type `string`. Length `64`. Not nullable.
   2. Run `dconsole make:entity`. Name it `Item`. No fields for now.
      1. Add field `name`. Type `string`. Length `255`. Not nullable.
      2. Add field `price`. Type `integer`. Nullable.
2. Create a relationship between entities:
   1. Run `dconsole make:entity`. Use the name `Warehouse` again to modify it:
      1. Add field `items`. Type `OneToMany`. Related to class `Item`. Inverse field named `warehouse`, not nullable, orphan removal enabled.
3. Generate an appropriate migration, e.g.:
   ```shell
   dconsole make:migration
   ```
4. Apply the migration, e.g.:
   ```shell
   dconsole doctrine:migration:migrate
   ```
5. Commit all changes, e.g.:
   ```shell
   git add --all && git commit -m 'Complete exercise 1'
   ```

Review points:

- Check out the code generated by the Symfony [Maker bundle](https://symfony.com/bundles/SymfonyMakerBundle/current/index.html).
- Also, feel free to connect to the PostgreSQL instance at `localhost:50443/app` and check out the tables that were automatically created.

### Exercise 2: Inject EntityManager

In the following exercises we will be modifying the file `src/Command/WorkshopCommand.php`, and then executing the corresponding Symfony command to see how our code performs.

1. To retrieve the Doctrine `EntityManager`, we will use Symfony dependency injection. There are at least two interfaces that can be injected for that purpose:
   1. `\Doctrine\ORM\EntityManagerInterface`. This is the most direct way.
   2. `\Doctrine\Persistence\ManagerRegistry`. This way, we get the entity manager by calling `ManagerRegistry::getManager`.
2. Run our command just to make sure it executes without errors, e.g.:
   ```shell
   dconsole workshop
   ```
3. Commit all changes, e.g.:
   ```shell
   git add --all && git commit -m 'Complete exercise 2'
   ```

Review points:

- Retrieving the entity manager through the manager registry is required when multiple entity managers exist.
- More importantly, through the manager registry we could cure the `ORMException` that tells us that `The EntityManager is closed.`. To learn more, check out the method `ManagerRegistry::resetManager`.

### Exercise 3: Enable SQL logging

1. Add the `monolog` bundle to our project, e.g.:
   ```shell
   docker run --rm --interactive --tty --volume $PWD:/app composer require monolog
   ```
2. Add a handler for the log channel `doctrine`:
   1. Modify the file `config/packages/monolog.yaml`. Add the following block to the section `when@dev.monolog.handlers`:
      ```yaml
               doctrine:
                   type: stream
                   path: php://stderr
                   level: debug
                   channels: ["doctrine"]
      ```
3. Commit all changes, e.g.:
   ```shell
   git add --all && git commit -m 'Complete exercise 3'
   ```
   
Review points:

- Monolog supports the concept of channels: grouping of logs by some topics. Doctrine uses the channel named, unsurprisingly, `doctrine`.
- Without a handler, a log channel will not go anywhere. So, we set up a handler that pipes the logs to `stderr`, _et voilà_.
- SQL queries/statements are logged at the `debug` level.

### Exercise 4: Create basic entities

1. Create, persist, and flush a simple pair of entities, e.g.:
   1. In the method `WorkshopCommand::execute`, add the following logic:
   ```php
           $item = (new Item())->setName('Grill')->setPrice(20000);
           $entityManager->persist($item);
           
           $warehouse = (new Warehouse())->setName('Marl');
           $entityManager->persist($warehouse);
           
           $warehouse->addItem($item);
   
           $entityManager->flush();
   ```
2. Run the command, e.g.:
   ```shell
   dconsole workshop
   ```
3. Commit all changes, e.g.:
   ```shell
   git add --all && git commit -m 'Complete exercise 4'
   ```

Review points:

- Entities are mutable and can exist in an inconsistent state. E.g., before we call `::addItem`, the item does not belong to any warehouse, even though it is forbidden by our relational constraints.
  - It is our responsibility to make sure the entities are set up completely before the `::flush` call.
- The order of `::persist` calls is not important: even though the `$item` is persisted before its related `$warehouse`, the code works because actual SQL queries are only executed on the call to `::flush`.
- Check the order of SQL statements: even though we persist the `$item` before the `$warehouse`, the warehouse is still inserted first, as this would be the only way to obey all constraints.
- The operations within the `::flush` call are wrapped in a transaction.

### Exercise 5: Create two thousand entities

1. Disable SQL logging, because this is about to get heavy:
   1. In the file `config/packages/doctrine.yaml`, add the following line to the section `doctring.dbal`:
   ```yaml
           logging: false
   ```
2. Prepare a method that reports the memory usage:
   1. In our `WorkshopCommand`, add the following method:
   ```php
       private function reportMemoryUsage(OutputInterface $output): void
       {
           $output->writeln(sprintf(
               '>> Memory used / allocated: %.1f MB / %.1f MB',
               memory_get_usage() / 1024 / 1024,
               memory_get_usage(true) / 1024 / 1024
           ));
       }
   ```
3. Create, persist, and flush two thousand entities:
   1. In the method `WorkshopCommand::execute`, add the following logic, replacing the stuff from previous exercise:
   ```php
           $start = microtime(true);
           $this->reportMemoryUsage($output);
   
           for ($i = 0; $i < 2_000; ++$i) {
               $warehouse = (new Warehouse())->setName('Warehouse #' . $i);
               $entityManager->persist($warehouse);
   
               $item = (new Item())->setName('Item #' . $i)->setPrice(100 + $i);
               $entityManager->persist($item);
   
               $warehouse->addItem($item);
               $entityManager->flush();
           }

           $this->reportMemoryUsage($output);
           $output->writeln(sprintf('Took %.1fs', microtime(true) - $start));
   ```
4. Run the command and observe the time and memory usage, e.g.:
   ```shell
   dconsole workshop
   ```
5. Apply optimizations, one by one, re-running the command every time to see the effects:
   1. Call `EntityManager::clear` at the end of every `for`-loop iteration.
   2. Before going into the `for`-loop, unset the Doctrine SQL logger, e.g.:
   ```php 
   $this->doctrine->getConnection()->getConfiguration()->setSQLLogger(null);
   ```
   3. After the `for`-loop is done, force PHP garbage collection, e.g.:
   ```php
   gc_collect_cycles(); 
   ```
   4. When invoking the `dconsole workshop` command, add the option `--no-debug`.
6. Try to lift the following lines of code out of the `for`-loop, then set the name of the warehouse to just `'Warehouse'`. Re-run the command and see what happens.
   ```php
            $warehouse = (new Warehouse())->setName('Warehouse #' . $i);
            $entityManager->persist($warehouse);
   ```
7. Commit all changes, e.g.:
   ```shell
   git add --all && git commit -m 'Complete exercise 5'
   ```

Review points:

- Clearing the entity manager cache speeds up the process considerably, but has little effect on memory usage, as the entities themselves are not that big.
- Most effective memory consumption optimizations come from disabling logging and debug modes, which might very well be done by default in Production.
- When clearing the entity manager cache, there is a risk that some entities may become orphaned. Thus, make sure to **not** retain any references to cleared (detached) entities.

### Exercise 6: Fetch a lot of entities

1. Erase all the entities created thus far, e.g.:
   ```shell
   dconsole doctrine:schema:drop --force && dconsole doctrine:schema:create
   ```
2. Create a set of entities by running this code inside the command:
   ```php 
           for ($i = 0; $i < 3; ++$i) {
               $warehouse = (new Warehouse())->setName('Warehouse #' . $i);
               $entityManager->persist($warehouse);
   
               for ($j = 0; $j < 2; ++$j) {
                   $item = (new Item())->setName('Item #' . $i . '-' . $j)->setPrice(100 + $j);
                   $entityManager->persist($item);
   
                   $warehouse->addItem($item);
               }
           }
           $entityManager->flush();
   ```
3. Re-enable SQL logging by setting the key `doctrine.dbal.logging` to `true` in the file `config/packages/doctrine.yaml`.
4. To fetch the newly created entities, create the following method in the file `src/Repository/WarehouseRepository.php`:
   ```php 
       public function findForWorkshop(): array
       {
           return $this->createQueryBuilder('w')
               ->select('w')
               ->andWhere('w.id > :val')
               ->setParameter('val', 0)
               ->orderBy('w.id', 'ASC')
               ->getQuery()
               ->getResult()
           ;
       }
   ```
5. Query the entities by running this code inside the command, and observe the number of SQL queries issued:
   ```php 
           /** @var WarehouseRepository $warehouseRepository */
           $warehouseRepository = $entityManager->getRepository(Warehouse::class);
   
           $warehouses = $warehouseRepository->findForWorkshop();
           foreach ($warehouses as $warehouse) {
               foreach ($warehouse->getItems() as $item) {
                   $output->writeln(sprintf('  >> %s (price %d) from %s', $item->getName(), $item->getPrice(), $warehouse->getName()));
               }
           }
   ```
6. There should be 4 `SELECT` queries logged. Now, let’s optimise. Introduce the following diff into the file `src/Repository/WarehouseRepository.php`:
   ```diff 
   -           ->select('w')
   +           ->select('w', 'i')
   +           ->join('w.items', 'i')
   ```
   1. Re-run the querying logic, and observe the number of SQL queries issued.
7. Retrieve the last item by appending the following block to the querying logic above:
   ```php 
           $itemId = $item->getId();
           $itemRepository = $entityManager->getRepository(Item::class);
           $lastItem = $itemRepository->find($itemId);
           $output->writeln('Last item is ' . $lastItem->getName());
   ```
   1. Re-run the querying logic, and observe whether the method `ItemRepository::find` generated an additional database call.
8. Now, slightly change the last block of code:
   ```diff 
   -       $lastItem = $itemRepository->find($itemId);
   +       $lastItem = $itemRepository->findOneBy(['id' => $itemId]);
   ```
   1. Re-run the querying logic, and observe whether the method `ItemRepository::findOneBy` generated an additional database call.

Review points:

- Pre-fetching potentially saves a lot of queries.
- When an entity is already in the entity manager’s cache, `find`-ing it by its ID does **not** generate a query.
  - However, finding it by any kind of criteria (even if the criteria is also the ID) **will** generate a query.
